<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Mercedes Game - KFZ Quiz</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #a0d7e6;
            font-family: 'Press Start 2P', cursive, sans-serif;
            overscroll-behavior: none;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            gap: 15px;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading-text {
            font-size: 1em;
        }

        #loading-progress {
            font-size: 0.8em;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 1px 1px 3px black;
            z-index: 50;
            font-size: 1.5em;
            pointer-events: none;
        }

        #score {
            margin-bottom: 5px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 4em;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 5px black;
            display: none;
            z-index: 101;
            pointer-events: auto;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        #restart-button {
            background-color: #21c60ffc;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.4em;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s ease;
        }

        #restart-button:hover {
            background-color: #1a9e0c;
        }

        /* Quiz Modal */
        #quiz-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #21c60f;
            z-index: 102;
            display: none;
            flex-direction: column;
            gap: 20px;
            max-width: 80%;
            box-shadow: 0 0 30px rgba(33, 198, 15, 0.5);
        }

        #quiz-question {
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
        }

        .quiz-answer {
            background-color: #333;
            color: white;
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            text-align: left;
        }

        .quiz-answer:hover {
            background-color: #444;
            border-color: #21c60f;
        }

        .quiz-answer.correct {
            background-color: #21c60f;
            border-color: #1a9e0c;
        }

        .quiz-answer.incorrect {
            background-color: #ff4444;
            border-color: #cc0000;
        }

        #quiz-feedback {
            font-size: 1em;
            text-align: center;
            min-height: 30px;
            font-weight: bold;
        }

        .control-button {
            position: absolute;
            bottom: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            z-index: 60;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5em;
            color: rgba(0, 0, 0, 0.7);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
        }

        .control-button:active {
            background-color: rgba(255, 255, 255, 0.5);
        }

        #left-button {
            left: 20px;
        }

        #right-button {
            right: 20px;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>

<body>
    <div id="loading-screen">
        <div id="loading-text">Loading Mercedes Game...</div>
        <div id="loading-progress">0%</div>
    </div>
    <div id="container"></div>

    <div id="ui-container">
        <div id="score">Score: 0</div>
    </div>

    <div id="game-over">
        GAME OVER!
        <button id="restart-button">Restart</button>
    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal">
        <div id="quiz-question"></div>
        <div id="quiz-answers"></div>
        <div id="quiz-feedback"></div>
    </div>

    <div id="left-button" class="control-button">â—€</div>
    <div id="right-button" class="control-button">â–¶</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        let scene, camera, renderer, carModel, enemyCar;
        let ambientLight, directionalLight;
        let road, roadLines = [], kerbs = [];
        let buildings = [], streetLights = [], trafficLights = [];
        const roadWidth = 10;
        const roadLength = 200;
        const sceneryRecycleDistance = roadLength / 2;
        const buildingSpacing = 15;
        const lightSpacing = 30;
        const numBuildings = Math.floor(roadLength * 1.5 / buildingSpacing);
        const numLights = Math.floor(roadLength * 1.5 / lightSpacing);

        const driveSpeed = 0.5;
        const enemyCarSpeed = 0.6;

        const kerbHeight = 0.2;
        const kerbWidth = 0.3;

        // Game State
        let moveLeft = false;
        let moveRight = false;
        const carMoveSpeed = 0.15;
        let carBaseY = 0;
        let score = 0;
        let isGameOver = false;
        let isPaused = false;

        // Points
        const points = [];
        const numPoints = 15;
        const pointValue = 10;
        let pointGeometry, pointMaterial;
        const pointRadius = 0.3;

        // Checkpoints
        const checkpoints = [];
        const numCheckpoints = 5;
        let checkpointGeometry, checkpointMaterial;
        const checkpointRadius = 1.5;
        const checkpointHeight = 8;

        // Quiz Questions (KFZ-specific)
        const quizQuestions = [
            {
                question: "Was bedeutet ABS?",
                answers: ["Antiblockiersystem", "Automatisches Bremssystem", "Anti-Beschleunigungs-System", "Airbag-Sicherheitssystem"],
                correct: 0
            },
            {
                question: "Welches Ã–l wird im Motor verwendet?",
                answers: ["GetriebeÃ¶l", "HydraulikÃ¶l", "MotorÃ¶l", "BremsflÃ¼ssigkeit"],
                correct: 2
            },
            {
                question: "Was prÃ¼ft die HU (Hauptuntersuchung)?",
                answers: ["Nur die Bremsen", "Verkehrssicherheit und UmweltvertrÃ¤glichkeit", "Nur den Motor", "Nur die Beleuchtung"],
                correct: 1
            },
            {
                question: "WofÃ¼r steht ESP im Auto?",
                answers: ["Extra Sicherheits-Paket", "Elektronisches StabilitÃ¤tsprogramm", "Engine Speed Protection", "Emergency Stop Protocol"],
                correct: 1
            },
            {
                question: "Was ist die Aufgabe der ZÃ¼ndkerze?",
                answers: ["Kraftstoff fÃ¶rdern", "Luft komprimieren", "Kraftstoff-Luft-Gemisch entzÃ¼nden", "Motor kÃ¼hlen"],
                correct: 2
            },
            {
                question: "Welche Einheit misst die Motorleistung?",
                answers: ["Volt", "Ampere", "PS oder kW", "Bar"],
                correct: 2
            },
            {
                question: "Was ist ein Turbolader?",
                answers: ["Ein KÃ¼hlsystem", "Ein Abgasreinigungssystem", "Eine Aufladung zur Leistungssteigerung", "Ein Bremssystem"],
                correct: 2
            },
            {
                question: "Wie oft sollte MotorÃ¶l gewechselt werden?",
                answers: ["Alle 100 km", "Nach Herstellerangaben (ca. 15.000-30.000 km)", "Alle 5 Jahre", "Nie"],
                correct: 1
            },
            {
                question: "Was bedeutet die AbkÃ¼rzung OBD?",
                answers: ["Oil Brake Diagnostic", "On-Board-Diagnose", "Optimal Brake Distribution", "Oil Based Drive"],
                correct: 1
            },
            {
                question: "Welcher Druck ist typisch fÃ¼r Autoreifen?",
                answers: ["0,5 bar", "2,0-2,5 bar", "10 bar", "100 bar"],
                correct: 1
            }
        ];

        let currentQuestion = null;
        let currentCheckpoint = null;

        // UI References
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgress = document.getElementById('loading-progress');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const quizModal = document.getElementById('quiz-modal');
        const quizQuestion = document.getElementById('quiz-question');
        const quizAnswers = document.getElementById('quiz-answers');
        const quizFeedback = document.getElementById('quiz-feedback');

        // Bounding Boxes
        let playerBox = new THREE.Box3();
        let enemyBox = new THREE.Box3();
        let pointBox = new THREE.Box3();
        let checkpointBox = new THREE.Box3();

        const loadingManager = new THREE.LoadingManager();

        loadingManager.onLoad = () => {
            console.log("All resources loaded!");
            loadingScreen.classList.add('hidden');
            setTimeout(() => {
                if (loadingScreen) loadingScreen.style.display = 'none';
                if (!isGameOver) animate();
            }, 600);
        };
        loadingManager.onError = (url) => {
            console.error(`There was an error loading ${url}`);
            loadingScreen.innerHTML = `<div style="font-size: 0.6em;">Error loading: ${url}<br>Check browser console for details</div>`;
            loadingScreen.classList.remove('hidden');
            loadingScreen.style.opacity = 1;
        };
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            const progress = Math.round((itemsLoaded / itemsTotal) * 100);
            loadingProgress.textContent = `${progress}%`;
        };

        init();
        setupControls();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6);
            scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, -7);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            const hdrPath = 'https://threejs.org/examples/textures/equirectangular/';
            const hdrName = 'venice_sunset_1k.hdr';

            new RGBELoader(loadingManager)
                .setPath(hdrPath)
                .load(hdrName, function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                    scene.background = texture;
                }, undefined, (error) => {
                    console.error('Error loading HDRI:', error);
                    scene.background = new THREE.Color(0xa0d7e6);
                });

            const groundGeo = new THREE.PlaneGeometry(roadWidth * 5, roadLength * 1.5);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, side: THREE.DoubleSide, roughness: 0.9, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength * 1.5);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 });
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.0;
            road.receiveShadow = true;
            scene.add(road);

            const lineLength = 4;
            const lineGap = 4;
            const numLines = Math.floor(roadLength * 1.5 / (lineLength + lineGap));
            const lineGeo = new THREE.PlaneGeometry(0.3, lineLength);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0.2, metalness: 0.0 });
            for (let i = 0; i < numLines; i++) {
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.y = 0.005;
                line.position.z = (roadLength * 1.5 / 2) - (lineLength / 2) - i * (lineLength + lineGap);
                line.receiveShadow = true;
                roadLines.push(line);
                scene.add(line);
            }

            function createKerbTexture() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 16;
                const stripeWidth = 8;
                const colors = ['#ff0000', '#ffffff'];
                for (let i = 0; i < canvas.width / stripeWidth; i++) {
                    ctx.fillStyle = colors[i % 2];
                    ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height);
                }
                return new THREE.CanvasTexture(canvas);
            }
            const kerbTexture = createKerbTexture();
            kerbTexture.wrapS = THREE.RepeatWrapping;
            kerbTexture.wrapT = THREE.ClampToEdgeWrapping;
            kerbTexture.repeat.set(roadLength * 1.5 / 4, 1);
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, kerbHeight, roadLength * 1.5);
            const kerbMat = new THREE.MeshStandardMaterial({ map: kerbTexture, roughness: 0.7, metalness: 0.1 });

            const kerbLeft = new THREE.Mesh(kerbGeo, kerbMat);
            kerbLeft.position.set(-(roadWidth / 2) - (kerbWidth / 2), kerbHeight / 2, 0);
            kerbLeft.castShadow = true;
            kerbLeft.receiveShadow = true;
            scene.add(kerbLeft);
            kerbs.push(kerbLeft);

            const kerbRight = new THREE.Mesh(kerbGeo, kerbMat);
            kerbRight.position.set((roadWidth / 2) + (kerbWidth / 2), kerbHeight / 2, 0);
            kerbRight.castShadow = true;
            kerbRight.receiveShadow = true;
            scene.add(kerbRight);
            kerbs.push(kerbRight);

            function createBuilding() {
                const height = Math.random() * 30 + 10;
                const width = Math.random() * 8 + 4;
                const depth = Math.random() * 8 + 4;
                const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                const buildingMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2),
                    roughness: 0.8,
                    metalness: 0.1
                });
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.y = height / 2;
                building.castShadow = true;
                building.receiveShadow = true;
                return building;
            }
            for (let i = 0; i < numBuildings; i++) {
                const buildingLeft = createBuilding();
                const buildingRight = createBuilding();
                const zPos = (roadLength * 1.5 / 2) - (buildingSpacing / 2) - i * buildingSpacing;
                const xOffsetLeft = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingLeft.geometry.parameters.width / 2;
                const xOffsetRight = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingRight.geometry.parameters.width / 2;
                buildingLeft.position.set(-xOffsetLeft, buildingLeft.position.y, zPos);
                buildingRight.position.set(xOffsetRight, buildingRight.position.y, zPos);
                buildings.push(buildingLeft, buildingRight);
                scene.add(buildingLeft);
                scene.add(buildingRight);
            }

            function createStreetLight() {
                const group = new THREE.Group();
                const poleHeight = 6;
                const poleRadius = 0.1;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.4 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.castShadow = true;
                pole.position.y = poleHeight / 2;
                group.add(pole);

                const armLength = 1.5;
                const armGeo = new THREE.BoxGeometry(armLength, poleRadius * 1.5, poleRadius * 1.5);
                const arm = new THREE.Mesh(armGeo, poleMat);
                arm.position.set(0, poleHeight - poleRadius * 2, 0);
                group.add(arm);

                const lightFixtureGeo = new THREE.SphereGeometry(poleRadius * 2, 16, 8);
                const lightFixtureMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffff00, emissiveIntensity: 0.5 });
                const lightFixture = new THREE.Mesh(lightFixtureGeo, lightFixtureMat);
                lightFixture.position.set(0, poleHeight - poleRadius * 2, 0);
                group.add(lightFixture);

                group.userData.armLength = armLength;
                return group;
            }
            for (let i = 0; i < numLights; i++) {
                const lightLeft = createStreetLight();
                const lightRight = createStreetLight();
                const zPos = (roadLength * 1.5 / 2) - (lightSpacing / 2) - i * lightSpacing;
                const xPos = roadWidth / 2 + kerbWidth + 0.8;

                lightLeft.position.set(-xPos, 0, zPos);
                lightLeft.rotation.y = Math.PI / 2;
                lightLeft.children[1].position.x = -lightLeft.userData.armLength / 2;
                lightLeft.children[2].position.x = -lightLeft.userData.armLength;
                streetLights.push(lightLeft);
                scene.add(lightLeft);

                lightRight.position.set(xPos, 0, zPos);
                lightRight.rotation.y = -Math.PI / 2;
                lightRight.children[1].position.x = -lightRight.userData.armLength / 2;
                lightRight.children[2].position.x = -lightRight.userData.armLength;
                streetLights.push(lightRight);
                scene.add(lightRight);
            }

            function createTrafficLight() {
                const group = new THREE.Group();
                const poleHeight = 5;
                const poleRadius = 0.15;
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.5 });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.y = poleHeight / 2;
                pole.castShadow = true;
                group.add(pole);

                const housingWidth = 0.5;
                const housingHeight = 1.2;
                const housingDepth = 0.3;
                const housingGeo = new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth);
                const housingMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const housing = new THREE.Mesh(housingGeo, housingMat);
                housing.position.y = poleHeight - housingHeight / 2;
                housing.castShadow = true;
                group.add(housing);

                const lightRadius = housingWidth * 0.25;
                const lightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);
                const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 1 });
                const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 1 });
                const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 1 });

                const redLight = new THREE.Mesh(lightGeo, redMat);
                redLight.position.set(0, housingHeight * 0.3, housingDepth / 2 + 0.01);
                housing.add(redLight);
                const yellowLight = new THREE.Mesh(lightGeo, yellowMat);
                yellowLight.position.set(0, 0, housingDepth / 2 + 0.01);
                housing.add(yellowLight);
                const greenLight = new THREE.Mesh(lightGeo, greenMat);
                greenLight.position.set(0, -housingHeight * 0.3, housingDepth / 2 + 0.01);
                housing.add(greenLight);

                return group;
            }
            const trafficLightLeft = createTrafficLight();
            const trafficLightRight = createTrafficLight();
            const trafficLightZ = roadLength * 0.4;
            const trafficLightX = roadWidth / 2 + kerbWidth + 0.5;
            trafficLightLeft.position.set(-trafficLightX, 0, trafficLightZ);
            trafficLightLeft.rotation.y = Math.PI / 2;
            trafficLightRight.position.set(trafficLightX, 0, trafficLightZ);
            trafficLightRight.rotation.y = -Math.PI / 2;
            trafficLights.push(trafficLightLeft, trafficLightRight);
            scene.add(trafficLightLeft);
            scene.add(trafficLightRight);

            // Points Setup
            pointGeometry = new THREE.SphereGeometry(pointRadius, 16, 16);
            pointMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 0.8, metalness: 0.9, roughness: 0.1 });
            for (let i = 0; i < numPoints; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.castShadow = true;
                point.receiveShadow = true;
                resetPointPosition(point, true);
                points.push(point);
                scene.add(point);
            }

            // Checkpoints Setup
            checkpointGeometry = new THREE.CylinderGeometry(checkpointRadius, checkpointRadius, checkpointHeight, 32);
            checkpointMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00aa00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.6,
                metalness: 0.5,
                roughness: 0.3
            });

            for (let i = 0; i < numCheckpoints; i++) {
                const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial.clone());
                checkpoint.castShadow = true;
                checkpoint.receiveShadow = true;
                checkpoint.userData.passed = false;
                resetCheckpointPosition(checkpoint, true);
                checkpoints.push(checkpoint);
                scene.add(checkpoint);
            }

            // Car Model Loading - MERCEDES
            const loader = new GLTFLoader(loadingManager);
            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            loader.setDRACOLoader(dracoLoader);

            // âœ… DEIN MERCEDES GITHUB LINK (Beachte den Bindestrich am Ende!)
            const carUrl = 'https://hidajetibusoski.github.io/mercedes-model-/models/mercedes.glb';
            
            // Fallback zu Ferrari falls Mercedes nicht lÃ¤dt
            const fallbackCarUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';

            console.log('ðŸš— Loading Mercedes from:', carUrl);

            loader.load(carUrl, (gltf) => {
                carModel = gltf.scene;
                
                // âš ï¸ Skalierung - ggf. anpassen je nach ModellgrÃ¶ÃŸe!
                // Probiere: 0.5, 0.8, 1.0, 1.5, 2.0
                carModel.scale.set(1.0, 1.0, 1.0);
                
                const box = new THREE.Box3().setFromObject(carModel);
                carBaseY = -box.min.y + 0.01;
                carModel.position.set(0, carBaseY, 0);
                carModel.rotation.y = Math.PI;

                carModel.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                scene.add(carModel);
                console.log("âœ… Mercedes loaded successfully!");

                // Enemy Car (blauer Mercedes)
                enemyCar = carModel.clone();
                enemyCar.traverse((node) => {
                    if (node.isMesh) {
                        const originalMaterial = node.material;
                        const enemyMaterial = originalMaterial.clone();
                        enemyMaterial.color.setHex(0x0000ff);
                        enemyMaterial.metalness = 0.9;
                        enemyMaterial.roughness = 0.2;
                        node.material = enemyMaterial;
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7);
                enemyCar.rotation.y = Math.PI;
                scene.add(enemyCar);
                console.log("âœ… Enemy Mercedes added (blue)");

                camera.position.set(0, carBaseY + 3, -7);
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);

            }, (progress) => {
                console.log('Loading progress:', Math.round((progress.loaded / progress.total) * 100) + '%');
            }, (error) => {
                console.error('âŒ Error loading Mercedes:', error);
                console.log('ðŸ”„ Trying Ferrari fallback...');
                
                // Fallback zu Ferrari
                loader.load(fallbackCarUrl, (gltf) => {
                    carModel = gltf.scene;
                    carModel.scale.set(0.8, 0.8, 0.8);
                    const box = new THREE.Box3().setFromObject(carModel);
                    carBaseY = -box.min.y + 0.01;
                    carModel.position.set(0, carBaseY, 0);
                    carModel.rotation.y = Math.PI;

                    carModel.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(carModel);

                    enemyCar = carModel.clone();
                    enemyCar.traverse((node) => {
                        if (node.isMesh) {
                            const originalMaterial = node.material;
                            const enemyMaterial = originalMaterial.clone();
                            enemyMaterial.color.setHex(0x0000ff);
                            enemyMaterial.metalness = 0.9;
                            enemyMaterial.roughness = 0.2;
                            node.material = enemyMaterial;
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                    enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7);
                    enemyCar.rotation.y = Math.PI;
                    scene.add(enemyCar);
                    console.log("âš ï¸ Ferrari fallback loaded");

                    camera.position.set(0, carBaseY + 3, -7);
                    camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
                }, undefined, (error) => {
                    console.error('âŒ Fallback also failed:', error);
                    // Letzter Fallback: Einfaches Box-Modell
                    const fallbackGeo = new THREE.BoxGeometry(2, 1, 4);
                    const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.5 });
                    carModel = new THREE.Mesh(fallbackGeo, fallbackMat);
                    carBaseY = 0.5 + 0.01;
                    carModel.position.set(0, carBaseY, 0);
                    carModel.castShadow = true;
                    carModel.receiveShadow = true;
                    scene.add(carModel);

                    enemyCar = new THREE.Mesh(fallbackGeo, new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5, metalness: 0.5 }));
                    enemyCar.position.set(roadWidth / 4, carBaseY, roadLength * 0.7);
                    enemyCar.castShadow = true;
                    enemyCar.receiveShadow = true;
                    scene.add(enemyCar);
                    console.log("âš ï¸ Using simple box fallback");

                    camera.position.set(0, carBaseY + 3, -7);
                    camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
                });
            });

            restartButton.addEventListener('click', restartGame);
            window.addEventListener('resize', onWindowResize, false);
            updateScoreDisplay();
        }

        function setupControls() {
            window.addEventListener('keydown', (event) => {
                if (isGameOver || isPaused) return;
                if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') { moveLeft = true; }
                else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') { moveRight = true; }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') { moveLeft = false; }
                else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') { moveRight = false; }
            });

            const leftButton = document.getElementById('left-button');
            const rightButton = document.getElementById('right-button');

            if (leftButton) {
                leftButton.addEventListener('pointerdown', (e) => { if (!isGameOver && !isPaused) { e.preventDefault(); moveRight = true; } }, { passive: false });
                leftButton.addEventListener('pointerup', (e) => { e.preventDefault(); moveRight = false; });
                leftButton.addEventListener('pointerleave', (e) => {
                    if (e.pointerType === 'touch') { moveRight = false; }
                });
            }
            if (rightButton) {
                rightButton.addEventListener('pointerdown', (e) => { if (!isGameOver && !isPaused) { e.preventDefault(); moveLeft = true; } }, { passive: false });
                rightButton.addEventListener('pointerup', (e) => { e.preventDefault(); moveLeft = false; });
                rightButton.addEventListener('pointerleave', (e) => {
                    if (e.pointerType === 'touch') { moveLeft = false; }
                });
            }
        }

        function resetPointPosition(point, initial = false) {
            const laneWidth = roadWidth / 2 - kerbWidth - pointRadius * 2;
            point.position.x = (Math.random() * 2 - 1) * laneWidth;
            point.position.y = pointRadius + 0.01;
            if (initial) {
                point.position.z = Math.random() * roadLength * 0.8 - roadLength * 0.4;
            } else {
                point.position.z = roadLength / 2 + Math.random() * roadLength * 0.5;
            }
            point.visible = true;
        }

        function resetCheckpointPosition(checkpoint, initial = false) {
            checkpoint.position.x = 0;
            checkpoint.position.y = checkpointHeight / 2;
            if (initial) {
                checkpoint.position.z = (roadLength / numCheckpoints) * (checkpoints.length) + Math.random() * 50;
            } else {
                checkpoint.position.z = roadLength / 2 + Math.random() * roadLength * 0.8;
            }
            checkpoint.userData.passed = false;
            checkpoint.material.emissiveIntensity = 0.5;
        }

        function updateScoreDisplay() {
            scoreElement.textContent = `Score: ${score}`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function showQuiz(checkpoint) {
            isPaused = true;
            currentCheckpoint = checkpoint;
            currentQuestion = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];

            quizQuestion.textContent = currentQuestion.question;
            quizAnswers.innerHTML = '';
            quizFeedback.textContent = '';

            currentQuestion.answers.forEach((answer, index) => {
                const button = document.createElement('div');
                button.className = 'quiz-answer';
                button.textContent = answer;
                button.addEventListener('click', () => checkAnswer(index, button));
                quizAnswers.appendChild(button);
            });

            quizModal.style.display = 'flex';
        }

        function checkAnswer(selectedIndex, button) {
            const allButtons = quizAnswers.querySelectorAll('.quiz-answer');
            allButtons.forEach(btn => btn.style.pointerEvents = 'none');

            if (selectedIndex === currentQuestion.correct) {
                button.classList.add('correct');
                quizFeedback.textContent = 'âœ“ Richtig! +50 Punkte';
                quizFeedback.style.color = '#21c60f';
                score += 50;
                updateScoreDisplay();
            } else {
                button.classList.add('incorrect');
                allButtons[currentQuestion.correct].classList.add('correct');
                quizFeedback.textContent = 'âœ— Falsch! Die richtige Antwort wird angezeigt.';
                quizFeedback.style.color = '#ff4444';
            }

            setTimeout(() => {
                quizModal.style.display = 'none';
                isPaused = false;
                if (currentCheckpoint) {
                    currentCheckpoint.userData.passed = true;
                    currentCheckpoint.material.emissiveIntensity = 0.1;
                }
            }, 2500);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isGameOver) {
                renderer.render(scene, camera);
                return;
            }

            if (isPaused) {
                renderer.render(scene, camera);
                return;
            }

            const deltaZ = driveSpeed;

            roadLines.forEach(line => {
                line.position.z -= deltaZ;
                if (line.position.z < -sceneryRecycleDistance) {
                    line.position.z += roadLength * 1.5;
                }
            });

            buildings.forEach(building => {
                building.position.z -= deltaZ;
                if (building.position.z < -sceneryRecycleDistance - building.geometry.parameters.depth / 2) {
                    const sideSign = Math.sign(building.position.x);
                    const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2;
                    building.position.set(sideSign * xOffset, building.geometry.parameters.height / 2, roadLength * 1.5 / 2 + Math.random() * buildingSpacing * 2);
                }
            });

            streetLights.forEach(light => {
                light.position.z -= deltaZ;
                if (light.position.z < -sceneryRecycleDistance) {
                    const sideSign = Math.sign(light.position.x);
                    const xPos = roadWidth / 2 + kerbWidth + 0.8;
                    light.position.set(sideSign * xPos, 0, roadLength * 1.5 / 2 + Math.random() * lightSpacing * 2);
                }
            });

            trafficLights.forEach(light => {
                light.position.z -= deltaZ;
                if (light.position.z < -sceneryRecycleDistance) {
                    const sideSign = Math.sign(light.position.x);
                    const xPos = roadWidth / 2 + kerbWidth + 0.5;
                    light.position.set(sideSign * xPos, 0, roadLength * 1.5 / 2 + Math.random() * roadLength * 0.5);
                }
            });

            kerbs.forEach(kerb => {
                kerb.position.z -= deltaZ;
                if (kerb.position.z < -sceneryRecycleDistance) {
                    kerb.position.z += roadLength * 1.5;
                }
            });

            points.forEach(point => {
                if (!point.visible) return;
                point.position.z -= deltaZ;
                point.rotation.y += 0.05;
                if (point.position.z < -sceneryRecycleDistance) {
                    resetPointPosition(point);
                }
            });

            checkpoints.forEach(checkpoint => {
                checkpoint.position.z -= deltaZ;
                checkpoint.rotation.y += 0.02;
                if (checkpoint.position.z < -sceneryRecycleDistance) {
                    resetCheckpointPosition(checkpoint);
                }
            });

            if (enemyCar && carModel) {
                enemyCar.position.z -= (enemyCarSpeed + driveSpeed);

                if (enemyCar.position.z < -sceneryRecycleDistance) {
                    enemyCar.position.z = roadLength * 0.7 + Math.random() * roadLength * 0.5;
                    enemyCar.position.x = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 2 - kerbWidth - 1);
                    enemyCar.rotation.y = Math.PI;
                }
            }

            if (carModel && carBaseY > 0) {
                let maxBounds = roadWidth / 2 - kerbWidth - 0.1;
                let carHalfWidth = 1;
                try {
                    const box = new THREE.Box3().setFromObject(carModel);
                    carHalfWidth = (box.max.x - box.min.x) / 2;
                    maxBounds = (roadWidth / 2) - kerbWidth - carHalfWidth - 0.1;
                } catch (e) { }

                if (moveLeft && carModel.position.x > -maxBounds) { carModel.position.x -= carMoveSpeed; }
                if (moveRight && carModel.position.x < maxBounds) { carModel.position.x += carMoveSpeed; }
                carModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, carModel.position.x));

                playerBox.setFromObject(carModel);
            }

            if (carModel) {
                const targetCameraX = carModel.position.x * 0.5;
                camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
            }

            if (carModel) {
                points.forEach(point => {
                    if (!point.visible) return;
                    pointBox.setFromObject(point);
                    if (playerBox.intersectsBox(pointBox)) {
                        score += pointValue;
                        updateScoreDisplay();
                        point.visible = false;
                    }
                });

                checkpoints.forEach(checkpoint => {
                    if (checkpoint.userData.passed) return;
                    checkpointBox.setFromObject(checkpoint);
                    if (playerBox.intersectsBox(checkpointBox)) {
                        showQuiz(checkpoint);
                    }
                });

                if (enemyCar && enemyCar.parent) {
                    enemyBox.setFromObject(enemyCar);
                    const expandedPlayerBox = playerBox.clone().expandByScalar(0.5);
                    if (expandedPlayerBox.intersectsBox(enemyBox)) {
                        console.log("Collision with enemy!");
                        isGameOver = true;
                        gameOverElement.style.display = 'flex';
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function restartGame() {
            isGameOver = false;
            isPaused = false;
            score = 0;
            updateScoreDisplay();
            gameOverElement.style.display = 'none';
            quizModal.style.display = 'none';

            if (carModel) {
                carModel.position.set(0, carBaseY, 0);
            }

            if (enemyCar) {
                const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * roadWidth / 4;
                enemyCar.position.set(initialEnemyX, carBaseY, roadLength * 0.7);
            }

            points.forEach(point => resetPointPosition(point, true));
            checkpoints.forEach(checkpoint => resetCheckpointPosition(checkpoint, true));

            roadLines.forEach((line, i) => {
                line.position.z = (roadLength * 1.5 / 2) - (line.geometry.parameters.height / 2) - i * (line.geometry.parameters.height + 4);
            });
            buildings.forEach((building, i) => {
                const zPos = (roadLength * 1.5 / 2) - (buildingSpacing / 2) - (i % (numBuildings / 2)) * buildingSpacing;
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2;
                building.position.set(sideSign * xOffset, building.geometry.parameters.height / 2, zPos);
            });
            streetLights.forEach((light, i) => {
                const zPos = (roadLength * 1.5 / 2) - (lightSpacing / 2) - (i % (numLights / 2)) * lightSpacing;
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xPos = roadWidth / 2 + kerbWidth + 0.8;
                light.position.set(sideSign * xPos, 0, zPos);
            });
            trafficLights.forEach((light, i) => {
                const zPos = roadLength * 0.4;
                const sideSign = (i % 2 === 0) ? -1 : 1;
                const xPos = roadWidth / 2 + kerbWidth + 0.5;
                light.position.set(sideSign * xPos, 0, zPos);
            });
        }

    </script>
</body>

</html>
